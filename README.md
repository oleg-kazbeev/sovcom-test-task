# sovcom-test-task
# Task 1

**Атрибуты:**
- `shares`: список долей.
- `percentages`: список процентных значений долей.

**Методы:**
- `read_input`: считывает данные с ввода.
- `calculate_percentages`: вычисляет процентное соотношение долей.
- `print_percentages`: выводит процентные значения.
- `process`: выполняет полный процесс обработки данных (чтение, расчет, вывод).

## Анализ вычислительной сложности и необходимой памяти

**Вычислительная сложность:**
- Сумма всех долей: `O(N)`
- Вычисление процентов: `O(N)`
- Общая сложность: `O(N)`

**Необходимая память:**
- Хранение входных данных: `O(N)`
- Хранение процентов: `O(N)`
- Общая память: `O(N)`

## Ограничения на размер входных параметров

`N ≤ 10^6`

## Субъективная оценка сложности задачи и затраченное время

Субъективная сложность задачи: **4 из 10**.
Затраченное время - 1.5 часа.

# Task 2
### Описание алгоритма рюкзака и его алгоритмическая сложность

Алгоритм рюкзака (knapsack algorithm) используется для решения задач, в которых необходимо выбрать подмножество элементов из набора так, чтобы максимизировать их суммарную ценность, не превышая при этом заданное ограничение (например, по весу или стоимости).

#### Основные шаги алгоритма

1. **Инициализация данных**:
   - Преобразуем входные данные в список лотов, где каждый лот представлен кортежем `(день, название, цена, количество)`.
   - Рассчитываем для каждого лота его стоимость и прибыль.

2. **Инициализация таблицы динамического программирования**:
   - Создаем таблицу `dp`, размером `(количество лотов + 1) x (доступный бюджет + 1)`, где `dp[i][w]` хранит максимальную прибыль, которую можно получить, рассматривая первые `i` лотов и используя бюджет `w`.

3. **Заполнение таблицы**:
   - Проходим по всем лотам и для каждого лота рассматриваем все возможные значения бюджета от `0` до `S`.
   - Обновляем значение `dp[i][w]`, сравнивая прибыль от включения текущего лота и прибыли без его включения.

4. **Восстановление выбранных лотов**:
   - После заполнения таблицы восстанавливаем выбранные лоты, проходя по таблице в обратном порядке и проверяя, какие лоты были включены в оптимальное решение.

#### Алгоритмическая сложность

`O(n * S)`, где `n` — количество лотов, а `S` — доступный бюджет. Эта сложность обусловлена тем, что мы заполняем таблицу размером `(n+1) * (S+1)`, и для каждого элемента таблицы выполняется константное количество операций.

## Субъективная оценка сложности задачи и затраченное время

Субъективная сложность задачи: **8 из 10**.
Затраченное время - 6 часов.
